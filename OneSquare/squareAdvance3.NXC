// 34 -> 67
// 22 -> 51

//Dirty Sheet
//12 / 39          L     (Black/White)
//17 / 50         R
//28 / 59         B

//Clean Sheet (WHite/ black)              Difference
// B 58 -> 32
// L 49 -> 15
// R 44 -> 10

// B 59 -> 29
// L 50 -> 35
// R 53 -> 19
/*  N
   33        45
   34        30
   42        58
   
  E
             65   37
             65   58
             59   59
  W
  12         47
  19         44
  37            62
                      */

const byte bSensor = IN_4;
const byte lSensor = IN_1;
const byte rSensor = IN_2;
const byte canSensor = IN_3;

const byte rMotor  = OUT_A;
const byte lMotor  = OUT_B;

const int Black1 = 40;
const int Black2 = 40;
const int Black4 = 45;

const long sqUnit    = 630;
const long lhTurn    = 266.25; // 0.425 * 630 - 90 degree turn
const long revTurn  = 535.5 ; // 0.85  * 630 - 180 degree turn

const int lMotorBias = 3;
const int rMotorBias = 0;
const long lineFollowBias = 1.5;
int moveDir = -100;  // Global Variable that stored the current directions of movement
long lRot, rRot = 0;

bool SensorLeft = false;
bool SensorRight = false;
bool SensorBack = false;

// Executor Code
string cmdList="Path.dat" ;
string readCmdList = "sLsLsRsRsRssLLssRRsLsLsLL" ;

void setupNXT(){
     SetSensorLight(bSensor);
	   SetSensorLight(lSensor);
	 SetSensorLight(rSensor);
	 ResetRotationCount(OUT_AB);
}

int powerMotors(int dir, char pwr){
	if (moveDir != dir){
		Off(OUT_AB);
		ResetRotationCount(OUT_AB);
		moveDir = dir;
		lRot = 0;
		rRot = 0;
	}
	switch (dir){
		case -1: //backwards
			OnRev(rMotor, pwr+rMotorBias);
			OnRev(lMotor, pwr+lMotorBias);
     return dir;
     break;
		case 0:	//forwards
      OnFwd(rMotor, pwr-rMotorBias);
			OnFwd(lMotor, pwr-lMotorBias);
     return dir;
     break;
		case 1:	//left
			OnRev(rMotor, pwr-rMotorBias);
			OnFwd(lMotor, pwr-lMotorBias);
     return dir;
     break;
		case 2: //right
			OnFwd(rMotor, pwr-rMotorBias);
			OnRev(lMotor, pwr-lMotorBias);
			break;

		default:
			Off(OUT_AB);
     return dir;
     break;
	}
}

 void dispSens(){
	int lSenVal = Sensor(lSensor);
	int rSenVal = Sensor(rSensor);
	int bSenVal = Sensor(bSensor);

  TextOut(0, LCD_LINE1, "L Sensor: ");
  TextOut(0, LCD_LINE2, "R Sensor: ");
  TextOut(0, LCD_LINE3, "B Sensor: ");

  NumOut(60, LCD_LINE1, lSenVal);
  NumOut(60, LCD_LINE2, rSenVal);
  NumOut(60, LCD_LINE3, bSenVal);

 }


void followLineNw(int pwr = 40){
  int bufRight  = 40-Sensor(IN_1);
  int bufLeft   = 40-Sensor(IN_2);

  if (moveDir ==0){

       int lSpeed = ((pwr-lMotorBias)+ ((bufLeft-bufRight)*lineFollowBias));
       int rSpeed = ((pwr-rMotorBias)+ ((bufRight-bufLeft)*lineFollowBias));

		OnFwd(rMotor, rSpeed);
		OnFwd(lMotor, lSpeed);
  }
  else if (moveDir == -1){

		int lSpeed = ((pwr+lMotorBias) + ((bufLeft-bufRight)*lineFollowBias));
		int rSpeed = ((pwr+rMotorBias) + ((bufRight-bufLeft)*lineFollowBias));

       OnRev(lMotor, lSpeed);
       OnRev(rMotor, rSpeed);
  }
}

void followLine(long pwr = 40){
followLineNw(pwr);
  //if(Sensor(bSensor) > Black4)
    //followLineNw(pwr);
  int bufferRight = 32-Sensor(IN_1);
  int buffeLeft   = 34-Sensor(IN_2);
  if (moveDir ==0){

     OnFwd(OUT_A, pwr + bufferRight);
     OnFwd(OUT_B, pwr-3 + buffeLeft);
  }
  else if (moveDir == -1){
       OnRev(OUT_A, pwr + bufferRight);
       OnRev(OUT_B, pwr-3 + buffeLeft);
  }
}

bool readRotation(long thresh){
	lRot = labs(MotorRotationCount(OUT_A));
	rRot = labs(MotorRotationCount(OUT_B));

	if ((lRot > thresh) && (rRot > thresh)){
    return true;
    }
  else
      return false;
}

void smallAdvance(){
     ResetRotationCount(OUT_AB);
     Wait(1);
     bool finish = false;
     powerMotors(0,50);
     while(!finish){
        finish = readRotation(170);
     }

}

bool turnStatus(){

  if(Sensor(IN_1) < Black1){SensorLeft = true;} //A
  if(Sensor(IN_2) < Black2){SensorRight = true;} //B
  if(Sensor(IN_4) < Black4){SensorBack = true;} //C

//  if(SensorLeft + SensorRight + SensorBack > 1){
    //if(SensorLeft + SensorRight > 1){
    if((SensorLeft || SensorRight) && SensorBack ){
    Off(OUT_AB);
    SensorLeft = false;
    SensorRight = false;
    SensorBack = false;
    return true;
  }
  else
	return false;
}

void oneSquare(bool canPresent = false){  // true = fwds, false = back

     ResetRotationCount(OUT_AB);
     //bool canPresent = Sensor(canSensor);
     bool finished = false;

     powerMotors(0, 100);
     Wait(200);
     int pwr = 90;
	if(!canPresent){
	while(!finished){
    dispSens();
    if(Sensor(bSensor) > Black4)
       pwr = 40;
    else
        pwr = 90;
		followLineNw(pwr);
		if((Sensor(lSensor) < Black1) && (Sensor(rSensor) < Black2) ){
			finished = true;
		}else{
			finished = readRotation(730);
		}
	}
	smallAdvance();
	Off(OUT_AB);
	Wait(1);
	}
}

void oneSquareCan(){  // true = fwds, false = back

     ResetRotationCount(OUT_AB);
     //bool canPresent = Sensor(canSensor);
     bool finished = false;

     powerMotors(0, 75);
     Wait(200);
		PlayTone(1000, 500);
		while(!finished){
			followLineNw(90);
			finished = readRotation(470);    //290
		}
		Off(OUT_AB);
}

void revSquare(){
     ResetRotationCount(OUT_AB);
     Wait(1);
     bool finished = false;
       powerMotors(-1, 50);
       Wait(1000);
	while(!finished){
  PlayTone(2500, 2000);
		followLineNw(50);
		if((Sensor(lSensor) < Black1) && (Sensor(rSensor) < Black2) ){
			finished = true;

		}else
        finished = readRotation(470);
	}
  smallAdvance();
	Off(OUT_AB);
}

void getPath(string &filename){
    byte handle;
    string inString;
    handle = fopen(filename , "r" );
    TextOut(0, LCD_LINE1, filename);
    if (handle != NULL)
    {
      ReadLnString(handle, readCmdList);
      TextOut(0, LCD_LINE2, "Commands Read:" );
      TextOut(0, LCD_LINE3, readCmdList);

      //return true;
    } else{
      TextOut(0, LCD_LINE1, "ERROR!");
      //return false;
      }
    fclose(handle);
}

bool turnSens(){

  while(true){
	    if(Sensor(lSensor) < Black1){SensorLeft = true;} //A
  if(Sensor(rSensor) < Black2){SensorRight = true;} //B
  if(Sensor(bSensor) < Black4){SensorBack = true;} //C
    dispSens();
    if(SensorLeft){
     if (SensorRight){
        SensorLeft = false;
        SensorRight = false;
        SensorBack = false;
        return true;
     }
    }
    else
    if(SensorRight){
     if (SensorLeft){
        SensorLeft = false;
        SensorRight = false;
        SensorBack = false;
        return true;
     }
    }
  }
  return false;
}

void lTurn(int numRot = 1){
	ResetRotationCount(OUT_AB);
	Wait(1);
	bool initRot = false;
	bool found = false;
	int initRotNum = 180;
  if (numRot ==2){           //for 180 degree turns
   initRotNum = lhTurn+130;
  }


	powerMotors(1, 90);
	while(!initRot){
	   initRot = readRotation(initRotNum);
	}
 powerMotors(1, 25);
 while(!found){
 dispSens();
  found = turnSens();
 }
 powerMotors(2,40);
 Wait(110);
 Off(OUT_AB);
}

void rTurn(int numRot = 1){
	ResetRotationCount(OUT_AB);
	Wait(1);
	bool initRot = false;
	bool found = false;
	int initRotNum = 180;
  if (numRot ==2){           //for 180 degree turns
   initRotNum = lhTurn+130;
  }

	powerMotors(2, 90);
	while(!initRot){
	   initRot = readRotation(initRotNum);
	}
 powerMotors(2, 25);
 while(!found){
  found = turnSens();
 }
 powerMotors(1,40);
 Wait(110);
 Off(OUT_AB);
}

void Executor(){
    bool MoveO = false;
    bool multi = false;
   for(int i = 0; i <= strlen(readCmdList); i++){
   string cmdCurrent = SubStr(readCmdList, i, 1);
   //count = 1;
   string cmdNxt = SubStr(readCmdList, i+1, 1);
       //PlayTone(200, 200);
			switch (cmdCurrent){
			case "F" :
         oneSquare();
         if(cmdNxt != "F" ){
          oneSquareCan();
          revSquare();
          }
	   	break;

      case "s" :
           oneSquare();
				break;

			case "B" :
           revSquare();//urn(2);
           Off(OUT_AB);
           Wait(100);
				break;
			case "L" :
         if(cmdNxt == "L" ){
                  lTurn(2);
                  MoveO = true;
                  }
		     else{
		          lTurn();
		 }
				break;
			case "R" :
         if(cmdNxt == "R" ){
                  rTurn(2);
                  MoveO = true;
                  }
		     else{
		          rTurn();
		 }
				break;
			default :
        PlayTone(7000, 1000);
				Off(OUT_AB);
				Wait(SEC_2);
				break;
    }
    Off(OUT_AB);

   Wait(50);
   if (MoveO){
      i++;
      MoveO = false;
      }
		}
}
task main(){
	setupNXT();

 getPath(cmdList);
  //while(1){
  Executor();//}
}
