const byte bSensor = IN_4;
const byte lSensor = IN_1;
const byte rSensor = IN_2;

const byte rMotor  = OUT_A;
const byte lMotor  = OUT_B;

const long sqUnit    = 630;
const long lTurn    = 266.25; // 0.425 * 630 - 90 degree turn
const long revTurn  = 535.5 ; // 0.85  * 630 - 180 degree turn
  
const int lMotorBias = 3;
const int rMotorBias = 0;
int state = -100;
long lRot, rRot = 0;

bool SensorLeft = false;
bool SensorRight = false;
bool SensorBack = false;

void setupNXT(){
     SetSensorLight(bSensor);
	 SetSensorLight(lSensor);
	 SetSensorLight(rSensor);
	 ResetTachoCount(OUT_AB);
}

int powerMotors(int dir, char pwr){
	if (state != dir){
		Off(OUT_AB);
		ResetRotationCount(OUT_AB);
		state = dir;
		lRot = 0;
		rRot = 0;
	}
	switch (dir){
		case -1: //backwards
			OnFwd(rMotor, pwr-rMotorBias);
			OnFwd(lMotor, pwr-lMotorBias);
			break;
		case 0:	//forwards
			OnRev(rMotor, pwr-rMotorBias);
			OnRev(lMotor, pwr-lMotorBias);
			break;
	
		case 1:	//left
			OnFwd(rMotor, pwr-rMotorBias);
			OnRev(lMotor, pwr-lMotorBias);
			break;
		
		case 2: //right
			OnRev(rMotor, pwr-rMotorBias);
			OnFwd(lMotor, pwr-lMotorBias);
			break;
		default:
			Off(OUT_AB);
			break;
	}
}

void followLine(long pwr = 40){
  int bufferRight = Sensor(rSensor);
  int buffeLeft = 	Sensor(lSensor);

  //OnRev(OUT_A, pwr + bufferRight);
  //OnRev(OUT_B, pwr-3 + buffeLeft);

}


bool readTacho(long thresh){
	lRot = labs(MotorRotationCount(OUT_A));
	rRot = labs(MotorRotationCount(OUT_B));
	
	if ((lRot > thresh) && (rRot > thresh)){
    return true;
    }
  else return false;
}



void oneSquare(){
	powerMotors(0, 50);
	bool running = true;
	while (running){
		followLine();
		if ( (Sensor(lSensor) < 55)  && (Sensor(rSensor) < 55) ){
			running = false;}
	}
	powerMotors(0,20);
	ResetRotationCount(OUT_AB);
	while(!readTacho(200)){	
	}
}

task main(){
	setupNXT();
//  oneSquare();
//  oneSquare();
//  oneSquare();
    while(true){
        followLine(50);
    }
 Off(OUT_AB);
}
